{"version":3,"file":"bundle.min.cjs","sources":["../src/common.ts","../src/scroll-step.ts","../src/scroll.ts","../src/scrollIntoView.ts","../src/scroll.polyfill.ts","../src/scrollIntoView.polyfill.ts","../src/polyfill.ts"],"sourcesContent":["import type { IScrollConfig } from \"./scroll-step\";\n\nexport const checkBehavior = (behavior?: string): behavior is undefined | ScrollBehavior => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\n\nexport function elementScrollXY(this: Element, x: number, y: number): void {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\n\nexport const failedExecute = (method: string, object: string, reason = \"cannot convert to dictionary.\"): string =>\n    `Failed to execute '${method}' on '${object}': ${reason}`;\n\nexport const failedExecuteInvalidEnumValue = (method: string, object: string, value: string): string =>\n    failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n\ninterface BackupMethod {\n    <K extends keyof Element>(proto: Element, method: K): Element[K] | undefined;\n    <K extends keyof Element>(proto: Element, method: K, fallback: unknown): Element[K];\n    <K extends keyof Window>(proto: Window, method: K): Window[K] | undefined;\n    <K extends keyof Window>(proto: Window, method: K, fallback: unknown): Window[K];\n}\n\n/* eslint-disable */\nexport const backupMethod: BackupMethod = (proto: any, method: string, fallback?: unknown) => {\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n\n    if (!proto[backup] && proto[method] && !proto[method]?.__isPolyfill) {\n        proto[backup] = proto[method];\n    }\n\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\n\nexport const isObject = (value: unknown): boolean => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\n\nexport const isScrollBehaviorSupported = (config?: IScrollConfig): boolean =>\n    \"scrollBehavior\" in window.document.documentElement.style && config?.forcePolyfill !== true;\n\nexport const markPolyfill = (method: () => void): void => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\n\ntype Prototype = typeof HTMLElement.prototype | typeof SVGElement.prototype | typeof Element.prototype;\n\nexport const modifyPrototypes = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\" | \"scrollIntoView\">(\n    prop: T,\n    func: Prototype[T],\n): void => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nexport const scrollingElement = (element: Element): Element =>\n    element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n","export interface IScrollConfig {\n    readonly duration?: number;\n    readonly forcePolyfill?: boolean;\n    readonly timingFunc?: (k: number) => number;\n}\n\nexport interface IContext extends IScrollConfig {\n    readonly timeStamp: number;\n    readonly startX: number;\n    readonly startY: number;\n    readonly targetX: number;\n    readonly targetY: number;\n    readonly method: (x: number, y: number) => void;\n    readonly callback: () => void;\n    rafId: number;\n}\n\nconst ease = (k: number) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n\n/* eslint-disable */\nexport function now(): number {\n    let fn: () => number;\n    if (window.performance?.now) {\n        fn = () => window.performance.now();\n    } else {\n        fn = () => window.Date.now();\n    }\n\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\n\nconst DURATION = 500;\n\nexport const step = (context: IContext): void => {\n    const currentTime = now();\n\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n\n    context.method(currentX, currentY);\n\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n","import {\n    backupMethod,\n    checkBehavior,\n    elementScrollXY,\n    failedExecute,\n    failedExecuteInvalidEnumValue,\n    isObject,\n    scrollingElement,\n} from \"./common.js\";\nimport type { IContext, IScrollConfig } from \"./scroll-step\";\nimport { now, step } from \"./scroll-step.js\";\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value: unknown): number => {\n    if (!isFinite(value as number)) {\n        return 0;\n    }\n    return Number(value);\n};\n\nconst isConnected = (node: Node) => {\n    return (\n        node.isConnected ??\n        (!node.ownerDocument ||\n            // eslint-disable-next-line no-bitwise\n            !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1))\n    );\n};\n\nconst scrollWithOptions = (element: Element, options: Readonly<ScrollToOptions>, config?: IScrollConfig): void => {\n    if (!isConnected(element)) {\n        return;\n    }\n\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n\n    const targetX = nonFinite(options.left ?? startX);\n    const targetY = nonFinite(options.top ?? startY);\n\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element) as Element, \"scroll\", fallback).bind(element);\n\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n\n    const context: IContext = {\n        ...config,\n        timeStamp: now(),\n        startX,\n        startY,\n        targetX,\n        targetY,\n        rafId: 0,\n        method,\n        callback: removeEventListener,\n    };\n\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n\n    step(context);\n};\n\nconst isWindow = (obj: unknown): obj is Window => (obj as Window).window === obj;\n\ninterface ScrollMethod<T extends Element | typeof window> {\n    (target: T, scrollOptions?: ScrollToOptions, config?: IScrollConfig): void;\n}\n\nconst createScroll =\n    <T extends Element | typeof window>(scrollName: \"scroll\" | \"scrollTo\" | \"scrollBy\"): ScrollMethod<T> =>\n    (target, scrollOptions, config): void => {\n        const [element, scrollType]: [Element, \"Window\" | \"Element\"] = isWindow(target)\n            ? [scrollingElement(target.document.documentElement), \"Window\"]\n            : [target, \"Element\"];\n\n        const options = scrollOptions ?? {};\n\n        if (!isObject(options)) {\n            throw new TypeError(failedExecute(scrollName, scrollType));\n        }\n\n        if (!checkBehavior(options.behavior)) {\n            throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n        }\n\n        if (scrollName === \"scrollBy\") {\n            options.left = nonFinite(options.left) + element.scrollLeft;\n            options.top = nonFinite(options.top) + element.scrollTop;\n        }\n\n        scrollWithOptions(element, options, config);\n    };\n\nexport const scroll = /* #__PURE__ */ createScroll(\"scroll\");\nexport const scrollTo = /* #__PURE__ */ createScroll(\"scrollTo\");\nexport const scrollBy = /* #__PURE__ */ createScroll(\"scrollBy\");\n\nexport const elementScroll = scroll as ScrollMethod<Element>;\nexport const elementScrollTo = scrollTo as ScrollMethod<Element>;\nexport const elementScrollBy = scrollBy as ScrollMethod<Element>;\n\nexport const windowScroll = scroll as ScrollMethod<typeof window>;\nexport const windowScrollTo = scrollTo as ScrollMethod<typeof window>;\nexport const windowScrollBy = scrollBy as ScrollMethod<typeof window>;\n","/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step\";\nimport { elementScroll } from \"./scroll.js\";\n\nconst enum ScrollAlignment {\n    ToEdgeIfNeeded,\n    CenterAlways,\n    LeftOrTop,\n    RightOrBottom,\n}\n\nconst enum WritingMode {\n    HorizontalTb,\n    VerticalRl,\n    VerticalLr,\n    SidewaysRl,\n    SidewaysLr,\n}\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode: string): WritingMode => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return WritingMode.HorizontalTb;\n\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return WritingMode.VerticalRl;\n\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return WritingMode.VerticalLr;\n\n        case \"sideways-rl\":\n            return WritingMode.SidewaysRl;\n\n        case \"sideways-lr\":\n            return WritingMode.SidewaysLr;\n    }\n\n    return WritingMode.HorizontalTb;\n};\n\ntype Tuple2<T> = [T, T];\n\nconst calcPhysicalAxis = <T>(writingMode: WritingMode, isLTR: boolean, hPos: T, vPos: T): [number, T, T] => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n\n    const enum OP {\n        ReverseHorizontal = 0b01,\n        ReverseVertical = 0b10,\n    }\n\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= OP.ReverseVertical;\n    }\n\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case WritingMode.HorizontalTb:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case WritingMode.VerticalRl:\n        case WritingMode.SidewaysRl:\n            //  reverse horizontal\n            layout ^= OP.ReverseHorizontal;\n            break;\n\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case WritingMode.SidewaysLr:\n            // reverse vertical\n            layout ^= OP.ReverseVertical;\n            break;\n    }\n\n    return [layout, hPos, vPos];\n};\n\nconst isXReversed = (computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    const layout = calcPhysicalAxis(\n        normalizeWritingMode(computedStyle.writingMode),\n        computedStyle.direction !== \"rtl\",\n        undefined,\n        undefined,\n    )[0];\n    return (layout & 1) === 1;\n};\n\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (\n    options: Readonly<ScrollIntoViewOptions>,\n    writingMode: WritingMode,\n    isLTR: boolean,\n): Tuple2<ScrollAlignment> => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(\n        writingMode,\n        isLTR,\n        options.block || \"start\",\n        options.inline || \"nearest\",\n    );\n\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return ScrollAlignment.CenterAlways;\n            case \"nearest\":\n                return ScrollAlignment.ToEdgeIfNeeded;\n\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? ScrollAlignment.LeftOrTop : ScrollAlignment.RightOrBottom;\n            }\n        }\n    }) as Tuple2<ScrollAlignment>;\n};\n\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (\n    align: ScrollAlignment,\n    scrollingEdgeStart: number,\n    scrollingEdgeEnd: number,\n    scrollingSize: number,\n    elementEdgeStart: number,\n    elementEdgeEnd: number,\n    elementSize: number,\n): Exclude<ScrollAlignment, ScrollAlignment.ToEdgeIfNeeded> | null => {\n    if (align !== ScrollAlignment.ToEdgeIfNeeded) {\n        return align;\n    }\n\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n    ) {\n        return null;\n    }\n\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n    ) {\n        return ScrollAlignment.LeftOrTop;\n    }\n\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if (\n        (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n    ) {\n        return ScrollAlignment.RightOrBottom;\n    }\n\n    return null;\n};\n\nconst canOverflow = (overflow: string | null): boolean => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = (element: Element): Element | null => {\n    try {\n        return element.ownerDocument.defaultView?.frameElement || null;\n    } catch {\n        return null;\n    }\n};\n\nconst isScrollable = (element: Element, computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (\n            canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element)\n        );\n    }\n\n    return false;\n};\n\nconst parentElement = (element: Element): Element | null => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return (pNode as ShadowRoot).host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n\n    return pElement;\n};\n\nconst clamp = (value: number, min: number, max: number): number => {\n    if (value < min) {\n        return min;\n    }\n\n    if (value > max) {\n        return max;\n    }\n\n    return value;\n};\n\nconst getSupportedScrollMarginProperty = (\n    ownerDocument: Document,\n): \"scroll-margin\" | \"scroll-snap-margin\" | undefined => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ([\"scroll-margin\", \"scroll-snap-margin\"] as const).filter(\n        (property) => property in ownerDocument.documentElement.style,\n    )[0];\n};\n\nconst getElementScrollSnapArea = (\n    element: Element,\n    elementRect: Readonly<DOMRect>,\n    computedStyle: Readonly<CSSStyleDeclaration>,\n): [top: number, right: number, bottom: number, left: number] => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n\n    const scrollMarginValue = (edge: \"top\" | \"right\" | \"bottom\" | \"left\"): number => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\n\nconst calcAlignEdge = (align: ScrollAlignment, start: number, end: number): number => {\n    switch (align) {\n        case ScrollAlignment.CenterAlways:\n            return (start + end) / 2;\n\n        case ScrollAlignment.RightOrBottom:\n            return end;\n\n        case ScrollAlignment.LeftOrTop:\n        case ScrollAlignment.ToEdgeIfNeeded:\n            return start;\n    }\n};\n\nconst getFrameViewport = (frame: Element, frameRect: Readonly<DOMRect>) => {\n    const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n    const [x, y, width, height] =\n        frame === scrollingElement(frame)\n            ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight]\n            : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n\n    return [top, right, bottom, left] as const;\n};\n\nconst computeScrollIntoView = (element: Element, options: ScrollIntoViewOptions): [Element, ScrollToOptions][] => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions: [Element, ScrollToOptions][] = [];\n\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n\n    if (!ownerWindow) {\n        return actions;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n\n    const writingMode = normalizeWritingMode(\n        computedStyle.writingMode ||\n            computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n            computedStyle.getPropertyValue(\"-ms-writing-mode\"),\n    );\n\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n\n        const frameRect = frame.getBoundingClientRect();\n\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n\n        const diffX =\n            eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY =\n            eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n\n    return actions;\n};\n\nexport const scrollIntoView = (\n    element: Element,\n    scrollIntoViewOptions?: ScrollIntoViewOptions,\n    config?: IScrollConfig,\n): void => {\n    const options = scrollIntoViewOptions || {};\n\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n\n    const actions = computeScrollIntoView(element, options);\n\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\n\nexport const elementScrollIntoView = scrollIntoView;\n","import { backupMethod, isScrollBehaviorSupported, markPolyfill, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step\";\nimport { scroll, scrollBy, scrollTo } from \"./scroll.js\";\n\ntype ScrollName = \"scroll\" | \"scrollTo\" | \"scrollBy\";\n\ntype Patch = <T extends ScrollName>(prop: T, func: (Element | typeof window)[T]) => void;\n\nconst createPolyfill =\n    (scrollName: ScrollName, patch: Patch) =>\n    (config?: IScrollConfig): void => {\n        if (isScrollBehaviorSupported(config)) {\n            return;\n        }\n\n        const scrollMethod = {\n            scroll,\n            scrollTo,\n            scrollBy,\n        }[scrollName];\n\n        patch(scrollName, function (this: Element | typeof window): void {\n            const args = arguments;\n            if (arguments.length === 1) {\n                scrollMethod(this, args[0] as ScrollToOptions, config);\n                return;\n            }\n\n            const left = args[0] as number;\n            const top = args[1] as number;\n            scrollMethod(this, { left, top });\n        });\n    };\n\nexport const elementScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyPrototypes);\nexport const elementScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyPrototypes);\nexport const elementScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyPrototypes);\n\nexport const modifyWindow = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\">(prop: T, func: typeof window[T]): void => {\n    markPolyfill(func);\n    backupMethod(window, prop);\n    window[prop] = func;\n};\n\nexport const windowScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyWindow);\nexport const windowScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyWindow);\nexport const windowScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyWindow);\n","import { backupMethod, isObject, isScrollBehaviorSupported, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step\";\nimport { elementScrollIntoView } from \"./scrollIntoView.js\";\n\nfunction elementScrollIntoViewBoolean(this: Element, alignToTop?: unknown) {\n    elementScrollIntoView(this, {\n        block: alignToTop ?? true ? \"start\" : \"end\",\n        inline: \"nearest\",\n    });\n}\n\nexport const elementScrollIntoViewPolyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    const originalFunc = backupMethod(window.HTMLElement.prototype, \"scrollIntoView\", elementScrollIntoViewBoolean);\n\n    modifyPrototypes(\"scrollIntoView\", function scrollIntoView(this: Element): void {\n        const args = arguments;\n        const options = args[0] as unknown;\n\n        if (args.length === 1 && isObject(options)) {\n            elementScrollIntoView(this, options as ScrollIntoViewOptions, config);\n            return;\n        }\n\n        originalFunc.apply(this, args as never);\n    });\n};\n","import { isScrollBehaviorSupported } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport {\n    elementScrollByPolyfill,\n    elementScrollPolyfill,\n    elementScrollToPolyfill,\n    windowScrollByPolyfill,\n    windowScrollPolyfill,\n    windowScrollToPolyfill,\n} from \"./scroll.polyfill.js\";\nimport { elementScrollIntoViewPolyfill } from \"./scrollIntoView.polyfill.js\";\n\nexport * from \"./scroll.polyfill.js\";\nexport * from \"./scrollIntoView.polyfill.js\";\n\nexport const polyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    elementScrollPolyfill(config);\n    elementScrollToPolyfill(config);\n    elementScrollByPolyfill(config);\n    elementScrollIntoViewPolyfill(config);\n\n    windowScrollPolyfill(config);\n    windowScrollToPolyfill(config);\n    windowScrollByPolyfill(config);\n};\n"],"names":["checkBehavior","behavior","undefined","elementScrollXY","x","y","this","scrollLeft","scrollTop","failedExecute","method","object","reason","failedExecuteInvalidEnumValue","value","backupMethod","proto","fallback","backup","__isPolyfill","isObject","type","isScrollBehaviorSupported","config","window","document","documentElement","style","forcePolyfill","markPolyfill","Object","defineProperty","modifyPrototypes","prop","func","HTMLElement","prototype","SVGElement","Element","forEach","scrollingElement","element","ownerDocument","ease","k","Math","cos","PI","now","fn","performance","Date","step","context","elapsed","timeStamp","duration","targetX","targetY","callback","timingFunc","currentX","startX","currentY","startY","rafId","requestAnimationFrame","nonFinite","isFinite","Number","createScroll","scrollName","target","scrollOptions","obj","_a","__read","scrollType","options","TypeError","left","top","node","isConnected","compareDocumentPosition","getPrototypeOf","bind","removeEventListener","cancelScroll","cancelAnimationFrame","addEventListener","passive","once","scrollWithOptions","scroll","scrollTo","scrollBy","elementScroll","elementScrollTo","elementScrollBy","windowScroll","windowScrollTo","windowScrollBy","normalizeWritingMode","writingMode","calcPhysicalAxis","isLTR","hPos","vPos","layout","isXReversed","computedStyle","direction","mapNearest","align","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","elementEdgeStart","elementEdgeEnd","elementSize","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","parentElement","pNode","parentNode","pElement","nodeType","host","defaultView","frameElement","getFrameElement","clamp","min","max","calcAlignEdge","start","end","getFrameViewport","frame","frameRect","visualViewport","_d","width","height","clientLeft","clientTop","computeScrollIntoView","actions","ownerWindow","getComputedStyle","block","inline","map","index","toPhysicalAlignment","getPropertyValue","alignH","alignV","_b","elementRect","right","bottom","scrollProperty","filter","property","scrollMarginValue","edge","parseInt","getElementScrollSnapArea","getBoundingClientRect","_c","dX","dY","frameStyle","position","frameTop","frameRight","frameBottom","frameLeft","eAlignH","eAlignV","diffX","diffY","moveX","moveY","push","scrollIntoView","scrollIntoViewOptions","scrollToOptions","elementScrollIntoView","createPolyfill","patch","scrollMethod","args","arguments","length","elementScrollPolyfill","elementScrollToPolyfill","elementScrollByPolyfill","modifyWindow","windowScrollPolyfill","windowScrollToPolyfill","windowScrollByPolyfill","elementScrollIntoViewBoolean","alignToTop","elementScrollIntoViewPolyfill","originalFunc","apply"],"mappings":"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"}